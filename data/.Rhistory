plot.background = element_rect(fill='transparent', color=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.background = element_rect(fill='transparent'),
legend.box.background = element_rect(fill='transparent')
)
ggsave("temp_line.png", device="png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Pleth_conf_exploratory/temp_line1.png",
bg="transparent")
ggplot(temp, aes(x = ID, y = Temp, group = 1)) +
geom_point(color="blue") +
geom_line(color="blue", linewidth=2) +
theme_classic()+
theme(
panel.background = element_rect(fill='transparent'),
plot.background = element_rect(fill='transparent', color=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.background = element_rect(fill='transparent'),
legend.box.background = element_rect(fill='transparent')
)
ggsave("temp_line.png", device="png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Pleth_conf_exploratory.png",
bg="transparent")
ggplot(temp, aes(x = ID, y = Temp, group = 1)) +
geom_point(color="blue") +
geom_line(color="blue", linewidth=2) +
theme_classic()+
theme(
panel.background = element_rect(fill='transparent'),
plot.background = element_rect(fill='transparent', color=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.background = element_rect(fill='transparent'),
legend.box.background = element_rect(fill='transparent')
)
ggsave("temp_line1.png", device="png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Pleth_conf_exploratory.png",
bg="transparent")
ggplot(temp, aes(x = ID, y = Temp, group = 1)) +
geom_point(color="blue") +
geom_line(color="blue", linewidth=2) +
theme_classic()+
theme(
panel.background = element_rect(fill='transparent'),
plot.background = element_rect(fill='transparent', color=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.background = element_rect(fill='transparent'),
legend.box.background = element_rect(fill='transparent')
)
ggsave("temp_line1.png", device="png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Pleth_conf_exploratory",
bg="transparent")
# Your plotting command
p <- ggplot(temp, aes(x = ID, y = Temp, group = 1)) +
geom_point(color="blue") +
geom_line(color="blue", linetype="solid", size=2) + # Changed linewidth to linetype and size for better control
theme_classic() +
theme(
panel.background = element_rect(fill='transparent'),
plot.background = element_rect(fill='transparent', color=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.background = element_rect(fill='transparent'),
legend.box.background = element_rect(fill='transparent')
)
# Save the plot
ggsave(filename = "temp_line2.png", plot = p, device = "png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Pleth_conf_exploratory",
width = 10, height = 8, units = "in", dpi = 300, bg = "transparent")
rm(list=ls())
setwd("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/data")
library(nimble)
library(ggplot2)
library(data.table)
library(tidyverse)
library(mcmcplots)
library(MCMCvis)
library(boot)
source('attach.nimble_v2.R')
## Load Data--------------------------------------------------------------------------------------------------
load("./all.spp_model.RData")
attach.nimble(mcmc.output.1$samples)
# Inverse logit the detection intercept to get detection probabilities
det.probs.inv <- inv.logit(DetectionIntercept)
## Looking into Temp effect -----------------------------------------------------------------------------------------------
# need to predict across a range of temperature values to really see what's happening with these
betaTemp <- betaTemp[,-2]
betaTemp <- as.matrix(betaTemp)
#length(scaled_temp)
#range(scaled_temp)
x_vals <- seq(-2.1, 3, by = 0.01)
l.det.prob <- mean(DetectionIntercept) + mean(betaTemp)*x_vals + mean(betaTemp2)*x_vals^2
det.prob <- inv.logit(l.det.prob)
mean_temp <- data$temp |> mean()
sd_temp <- data$temp |> sd()
temp_vals <- x_vals*sd_temp + mean_temp
plot(l.det.prob ~ temp_vals) #doesnt work
rm(list=ls())
library(nimble)
library(ggplot2)
library(data.table)
library(tidyverse)
library(mcmcplots)
library(MCMCvis)
library(boot)
source('attach.nimble_v2.R')
load("./all.spp_model.RData")
attach.nimble(mcmc.output.1$samples)
trt.int.inv <- inv.logit(TreatmentIntercept) # Inv logit TreatmentIntercept to get Occupancy Estimates
treatment_matrix <- trt.int.inv
box.colors.1 <- c('lightgreen','steelblue', 'coral2', '#f9d62e','#b967ff' )
# Build matrix of trt - control effects
diff.BS <- TreatmentIntercept[,1]-TreatmentIntercept[,5]
diff.BU <- TreatmentIntercept[,2]-TreatmentIntercept[,5]
diff.HB <- TreatmentIntercept[,3]-TreatmentIntercept[,5]
diff.HU <- TreatmentIntercept[,4]-TreatmentIntercept[,5]
diff.UU <- TreatmentIntercept[,5]-TreatmentIntercept[,5]
trt.diff.new <- cbind(diff.BS, diff.BU, diff.HB, diff.HU, diff.UU)
new.names <- c("Salvage Logged", "Wildfire", "Harvest, Wildfire", "Harvest", "Control")
colnames(trt.diff.new) <- new.names
desired.order <- c("Control", "Wildfire", "Harvest, Wildfire", "Harvest", "Salvage Logged")
# Boxplot showing negative effect sizes of each treatment
png("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Trt_effect_size_nimble/Boxplot_trt_effect.png")
boxplot(trt.diff.new [, match(desired.order, colnames(trt.diff.new))],
main= "Effect Size by Treatment",
xlab = "Treatment",
ylab = "Effect Size",
col = box.colors.1)
dev.off()
png("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Trt_effect_size_nimble/Boxplot_trt_effect1.png")
boxplot(trt.diff.new [, match(desired.order, colnames(trt.diff.new))],
main= "Effect Size by Treatment",
xlab = "Treatment",
ylab = "Effect Size",
col = box.colors.1)
dev.off()
rm(list=ls())
setwd("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/data")
library(nimble)
library(ggplot2)
library(data.table)
library(tidyverse)
library(mcmcplots)
library(MCMCvis)
library(boot)
source('attach.nimble_v2.R')
load("./all.spp_model.RData")
attach.nimble(mcmc.output.1$samples)
data <- read.csv("sitecovs_obs_long.csv")
data$site <- as.numeric(data$site)
data$all.obs <- as.numeric(data$all.obs)
data$oss.obs <- as.numeric(data$oss.obs)
data$enes.obs <- as.numeric(data$enes.obs)
data2 <- read.csv("site_treatments.csv")
data2$site <- as.numeric(data2$site)
data2$treatment <- as.numeric(factor(data2$treatment))
table(data2$treatment)
scaled_temp <- c(scale(data$temp))
all.spp.model.1 <- nimbleCode ({
# Priors
for(t in 1:n.treatments){
TreatmentIntercept[t] ~ dunif(-10,10)
}#t
DetectionIntercept ~ dunif(-5,5)
betaTemp ~ dunif(-5, 5)
betaTemp2 ~ dunif(-5, 0)
# Likelihood
# Process/Biological model = Occupancy
# need two pieces: one defining psi and covariates, and one defining z dist
for(i in 1:n.sites) {
logit(psi[i]) <- TreatmentIntercept[treatment[i]]  #psi=occupancy probability
z[i] ~ dbern(psi[i])  # z=1 if occupied, z=latent true occupancy
}#i
# Observation model = Detection
# need two pieces: one for det coeff and one defining Y distribution
for(j in 1:n.obs) {
logit(p[j]) <- DetectionIntercept + betaTemp*temp[j] + betaTemp2*temp[j]^2
#p=detection probability for site i and survey j
Y[j] ~ dbern(p[j] * z[site[j]]) #Y=my actual data observations
#z=1 or 0, turns this on or off
}#j
})
# Parameters monitored
parameters <- c("z","p","TreatmentIntercept","DetectionIntercept","betaTemp", "betaTemp2")
# MCMC Settings
ni <- 40000
nt <- 40
nb <- 20000
nc <- 3
# Data
nimble.data = list(Y=data$all.obs,
temp=scaled_temp)
nimble.constants = list(n.sites = length(unique(data$site)),
n.treatments = length(unique(data2$treatment)),
treatment=data2$treatment,
site=as.numeric(as.factor(data$site)),
n.obs = length(data$all.obs))
mcmc.output.1 <- nimbleMCMC(code = all.spp.model.1,
data = nimble.data,
constants=nimble.constants,
monitors = parameters,
niter = ni,
nburnin = nb,
nchains = nc,
thin=nt,
summary=TRUE,
samplesAsCodaMCMC = TRUE)
attach.nimble(mcmc.output.1$samples)
save(mcmc.output.1, file="./all.spp_model.RData")
load("./all.spp_model.RData")
# Gelman-Rubin diagnostic (AKA RHat or PSRF)
z <- mcmc.output.1$samples
g <- matrix(NA, nrow=nvar(z), ncol=2)
for (v in 1:nvar(z)) { g[v,] <- gelman.diag(z[,v])$psrf }
PSRF <- bind_cols(colnames(z$chain1),g) %>% rename(Parameter = ...1 ,PSRF = ...2 ,PSRFUpperCI = ...3)
PSRF # Values are below 1.05, so that's good
# Inverse logit the detection intercept to get detection probabilities
det.probs.inv <- inv.logit(DetectionIntercept)
# Looking at trace plots and parameter estimates
MCMCtrace(object = mcmc.output.1$samples,
pdf = FALSE, # no export to PDF
ind = TRUE, # separate density lines per chain
params = c("DetectionIntercept", "betaTemp", "TreatmentIntercept"))
#mean(det.probs.inv) # = 0.3207378
#mean(det.probs.inv>0)  # = 1
#median(det.probs.inv)  # = 0.3198026
boxplot(det.probs.inv)
# Inv logit TreatmentIntercept to get Occupancy Estimates
trt.int.inv <- inv.logit(TreatmentIntercept)
# Boxplot of Treatment Estimates
png("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Trt_occu_prob_nimble/Boxplot_trt_occu_prob_nimble.png")
boxplot(treatment_matrix[, match(desired.order, colnames(treatment_matrix))],
main = "Treatment Intercepts for All Species",
xlab = "Treatment", ylab = "Occupancy Probability",
col = box.colors)
dev.off()
treatment_matrix <- trt.int.inv # Using the inv logit treatment estimates
new.names <- c("Salvage Logged", "Wildfire", "Harvest, Wildfire", "Harvest", "Control")
colnames(treatment_matrix) <- new.names
desired.order <- c("Control", "Wildfire", "Harvest, Wildfire", "Harvest", "Salvage Logged")
box.colors <- c('lightgreen','steelblue', 'coral2', '#f9d62e', '#b967ff' )
png("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Trt_occu_prob_nimble/Boxplot_trt_occu_prob_nimble.png")
boxplot(treatment_matrix[, match(desired.order, colnames(treatment_matrix))],
main = "Treatment Intercepts for All Species",
xlab = "Treatment", ylab = "Occupancy Probability",
col = box.colors)
dev.off()
rm(list=ls())
setwd("C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/data")
library(unmarked)
library(ggplot2)
library(stats)
library(MASS)
hum <- read.csv("detcov_humidity.csv", row.names = 1)
temp <- read.csv("detcov_temp.csv", row.names = 1 )
weather <- read.csv("detcov_weather.csv", row.names = 1 )
date <- read.csv("detcov_juliandate.csv", row.names = 1 )
soilmoist <- read.csv("detcov_soilmoist.csv", row.names = 1 )
scaled_hum <- as.data.frame(scale(hum))
scaled_temp <- as.data.frame(scale(temp))
scaled_date <- as.data.frame(scale(date))
scaled_soilmoist <- as.data.frame(scale(soilmoist))
# Occupancy Covariates
sitecovs <- read.csv("sitecovs.csv")
# Occupancy Covariates
sitecovs <- read.csv("sitecovs.csv")
# Reorder treatments
sitecovs$treatment <- factor(sitecovs$treatment,
levels = c("UU", "BU", "HB", "HU", "BS"))
# Scale Occupancy Covariates
sitecovs$site <- as.character(sitecovs$site)
# Identify numeric sitecovs
numeric_sitecovs <- sitecovs[sapply(sitecovs, is.numeric)]
# Scale the numeric sitecovs
scaled_numeric_sitecovs <- as.data.frame(scale(numeric_sitecovs))
# Combine the scaled numeric sitecovs with non-numeric sitecovs
scaled_sitecovs <- cbind(scaled_numeric_sitecovs, sitecovs[setdiff(names(sitecovs), names(numeric_sitecovs))])
## Species data
oss.dat <- read.csv("OSS_occ_7.csv")
oss.dets <- oss.dat[,-1]
enes.dat <- read.csv("ENES_occ_7.csv")
enes.dets <- enes.dat[,-1]
## OSS Top Model Exploration-------------------------------------------------------------------------------
# Build OSS unmarkedFrameOccu Object
UMF.oss.scaled <- unmarkedFrameOccu(
y = oss.dets,
obsCovs = list(humidity = scaled_hum, temp = scaled_temp, weather = weather, date = scaled_date,
soilmoist = scaled_soilmoist),
siteCovs = scaled_sitecovs)
# 4: psi(treatment) p(x) , x = date, treatment, or soil moisture
m4 <- occu(~temp ~treatment, data=UMF.oss.scaled)
## Extract treatment occupancy predictions and plot --------------------------------------------------------
# Extract psi predictions from model 4
preds4 <- predict(m4, type="state")
sites_trt <- sitecovs[, c("site","treatment")]
site_preds4 <- cbind(sites_trt, preds4)
ggplot(site_preds4, aes(x = treatment, y = Predicted, ymin = lower, ymax = upper, fill = treatment)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
geom_errorbar(aes(ymax = upper, ymin = lower), width = 0.25, position = position_dodge(width = 0.7), linewidth = 1) +
labs(title = "OSS: Treatment vs. Predicted Occupancy",
x = "Treatment", y = "Predicted Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set1")
ggsave("unmarked_occu_barplot_oss.png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Unmarked_occu_TWS_2023")
ggplot(site_preds4, aes(x = treatment, y = Predicted, ymin = lower, ymax = upper, fill = treatment)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
geom_errorbar(aes(ymax = upper, ymin = lower), width = 0.25, position = position_dodge(width = 0.7), linewidth = 1) +
labs(title = "OSS: Treatment vs. Predicted Occupancy",
x = "Treatment", y = "Predicted Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set1")
ggsave("unmarked_occu_barplot_oss.png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Unmarked_occu_TWS_2023a")
ggplot(site_preds4, aes(x = treatment, y = Predicted, ymin = lower, ymax = upper, fill = treatment)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
geom_errorbar(aes(ymax = upper, ymin = lower), width = 0.25, position = position_dodge(width = 0.7), linewidth = 1) +
labs(title = "OSS: Treatment vs. Predicted Occupancy",
x = "Treatment", y = "Predicted Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set1")
ggsave("unmarked_occu_barplot_oss1.png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Unmarked_occu_TWS_2023")
ggplot(site_preds4, aes(x = treatment, y = Predicted, fill = treatment)) +
geom_boxplot() +
geom_point(position = position_dodge(width = 0.75), size = 3) +
geom_errorbar(aes(ymax = upper, ymin = lower), width = 0.25, position = position_dodge(width = 0.75), size = 1) +
labs(title = "OSS: Treatment vs. Predicted Occupancy",
x = "Treatment", y = "Predicted Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set1")
ggsave("unmarked_occu_pt_est_oss.png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Unmarked_occu_TWS_2023")
## ENES Top Model Exploration-------------------------------------------------------------------------------
# Build ENES unmarkedFrameOccu Object
UMF.enes.scaled <- unmarkedFrameOccu(
y = enes.dets,
obsCovs = list(humidity = scaled_hum, temp = scaled_temp, weather = weather, date = scaled_date,
soilmoist = scaled_soilmoist),
siteCovs = scaled_sitecovs)
summary(UMF.enes.scaled)
# 4: psi(treatment) p(x) , x = date, treatment, or soil moisture      *************************
m8 <- occu(~temp ~treatment, data=UMF.enes.scaled)
## Extract treatment occupancy predictions and plot ---------------------------------------------------------
# Extract psi predictions from model 8
preds8 <- predict(m8, type="state")
sites_trt <- sitecovs[, c("site","treatment")]
site_preds8 <- cbind(sites_trt, preds8)
ggplot(site_preds8, aes(x = treatment, y = Predicted, ymin = lower, ymax = upper, fill = treatment)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
geom_errorbar(aes(ymax = upper, ymin = lower), width = 0.25, position = position_dodge(width = 0.7), linewidth = 1) +
labs(title = "ENES: Treatment vs. Predicted Occupancy",
x = "Treatment", y = "Predicted Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set1")
ggsave("unmarked_occu_barplot_enes.png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Unmarked_occu_TWS_2023")
ggplot(site_preds8, aes(x = treatment, y = Predicted, fill = treatment)) +
geom_boxplot() +
geom_point(position = position_dodge(width = 0.75), size = 3) +
geom_errorbar(aes(ymax = upper, ymin = lower), width = 0.25, position = position_dodge(width = 0.75), size = 1) +
labs(title = "ENES: Treatment vs. Predicted Occupancy",
x = "Treatment", y = "Predicted Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set1")
ggsave("unmarked_occu_pt_est_enes.png",
path = "C:/Users/jasmi/OneDrive/Documents/Academic/OSU/Git/Occupancy-2023/figures/Unmarked_occu_TWS_2023")
rm(list=ls())
## View the first rows of the trees dataframe
head(trees)
## Take a look at a specific column of data (this is a vector!)
trees$Height
## Look at unique values in a column/variable
unique(trees$Volume)
## Check how many rows there are in a dataframe
nrow(trees)
# 1. mtcars is another dataset in base R - take a look at it!
mtcars
# 2. How many columns does mtcars contain?
ncol(mtcars)
# 3. How many rows does mtcars contain?
nrow(mtcars)
# 4. How many unique values are there in the gear column?
unique(mtcars$gear)
# 4. How many unique values are there in the gear column?
count(unique(mtcars$gear))
# 5. Calculate the mean mpg in mtcars and assign it to the variable mpg_mean
mpg_mean <- mean(mtcars$mpg)
# 6. Calculate the standard deviation of mpg in mtcars and assign it to the variable mpg_stdev
mpg_stdev <- sd(mtcars$mpg)
# 7. Print out the variable mpg_stdev
mpg_stdev
# 8. Plot mpg_mean
plot(mpg_stdev)
# 8. Plot mpg_mean
plot(mpg_mean)
dev.off()
# 8. Plot mpg_mean
plot(mpg_mean)
# 8. Plot mpg_mean
plot(mpg_stdev)
# 8. Plot mpg_mean
plot(mtcars$mpg)
abline(h=mpg_mean)
browseVignettes(ggplot)
browseVignettes(ggplot2)
load(ggplot)
## Check out the dataset 'airquality'
head(airquality)
nrow(airquality)
## Make a boxplot of ozone levels by month
boxplot(Ozone ~ Month, airquality, xlab = "Month", ylab = "Ozone (ppb)")
## Make a histogram of ozone levels
hist(airquality$Ozone)
# Make a scatterplot of ozone levels by wind speed
plot(Ozone ~ Wind, airquality)
# Adding more detail to the plot...
title(main = "Ozone and Wind in New York City")
points(Ozone ~ Wind, airquality, subset=Month==5, col="blue")
points(Ozone ~ Wind, airquality, subset=Month==6, col="red")
points(Ozone ~ Wind, airquality, subset=Month==7, col="orange")
points(Ozone ~ Wind, airquality, subset=Month==8, col="purple")
points(Ozone ~ Wind, airquality, subset=Month==9, col="green")
legend("topright", legend=c("5","6","7","8","9"), pch = 1,
col = c("blue", "red", "orange", "purple", "green"), title = "Month")
install.packages("tidyverse")
library(tidyverse)
# If you have a mac & this doesn't run, try loading the package components separately
# library(ggplot2) # plots
# library(dplyr) # helpful for data wrangling
# Let's look at some data!
# Load the 'penguins' dataset from CRAN (penguins are more fun!)
install.packages("palmerpenguins")
library(palmerpenguins)
# Can now call 'penguins' dataset like any other pre-loaded R dataset (mtcars, iris, etc)
data(penguins)
force(penguins)
# Now take a look at this to see how it's structured, column names, values, etc.
head(penguins)
nrow(penguins) # 344 observations
summary(penguins)
install.packages("tidyverse")
install.packages("palmerpenguins")
library(palmerpenguins)
# Can now call 'penguins' dataset like any other pre-loaded R dataset (mtcars, iris, etc)
data(penguins)
force(penguins)
# Now take a look at this to see how it's structured, column names, values, etc.
head(penguins)
nrow(penguins) # 344 observations
summary(penguins)
install.packages("palmerpenguins")
library(tidyverse)
library(palmerpenguins)
# Take advantage of RStudio! Look at the full dataset
View(penguins)
# Do we have missing values? AKA NAs?
sum(rowSums(is.na(penguins)) > 0)
# Do we have missing values? AKA NAs?
sum(rowSums(is.na(penguins)) > 0)
# For practice tidying data, let's remove NAs
tidy_penguins <- drop_na(penguins)
nrow(tidy_penguins) # 333 observations after all missing values removed.
# Let's give it a go! Make a scatter plot of the relationship between bill length (x) and bill depth (y)
bill_len_dep <- ggplot(data = tidy_penguins,
aes(x = bill_length_mm,
y = bill_depth_mm,
group = species))  # start the plot, set the plot aesthetics
show(bill_len_dep)
# Now add the point 'layer'
bill_len_dep <- bill_len_dep +
geom_point()
show(bill_len_dep)
# Okay! Now that we know what we're doing...
pretty_len_dep <- ggplot(data = tidy_penguins,
aes(x = bill_length_mm,
y = bill_depth_mm,
group = species)) +
geom_point(aes(color = species,
shape = species),
size = 3,
alpha = 0.8) # alpha sets transparency level
show(pretty_len_dep)
ggplot(data = tidy_penguins,
aes(x = bill_length_mm,
y = bill_depth_mm,
group = species)) +
geom_point(aes(color = species,
shape = species),
size = 3, alpha = 0.8) +
scale_color_manual(values = c("yellow", "blue", "green"))
ggplot(data = tidy_penguins,
aes(x = bill_length_mm,
y = bill_depth_mm,
color = flipper_length_mm)) +
geom_point(size = 3, alpha = 0.8)
# Now its your turn!
# Try making a histogram of body weight by species to start, then practice making some fun, funky,
# and informorative plots of your own.
ggplot(data = tidy_penguins,
aes(x=body_mass_g)) +
geom_histogram() +
facet_wrap(~species, ncol=1) +
theme_bw()
